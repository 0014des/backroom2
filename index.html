<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Backrooms Escape - Endless</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Courier New', Courier, monospace; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        #info { padding: 20px; text-shadow: 1px 1px 2px black; font-size: 14px; color: #ddd; }
        
        /* クロスヘア */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 20px; height: 20px; 
            border: 2px solid rgba(200, 50, 50, 0.5);
            border-radius: 50%; 
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 5px red;
            transition: all 0.2s ease-out;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 2px; height: 2px; background: red;
            transform: translate(-50%, -50%);
        }
        #crosshair.aiming { 
            width: 4px; height: 4px; 
            border-color: rgba(50, 255, 50, 0.8);
            background-color: rgba(50, 255, 50, 0.3);
            box-shadow: 0 0 5px lime;
        }
        #crosshair.shotgun {
            width: 40px; height: 40px;
            border-style: dashed;
        }
        #crosshair.shotgun.aiming {
            width: 15px; height: 15px;
        }

        /* レティクル横の弾薬ゲージ */
        #reticle-ammo {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(25px, -50%); 
            display: flex;
            flex-wrap: wrap; 
            width: 120px;    
            gap: 3px;
            align-items: center;
            pointer-events: none;
        }
        
        .ammo-pip {
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 2px black;
            transition: opacity 0.1s;
        }
        
        .ammo-pip.empty {
            background-color: transparent;
            border: 1px solid rgba(100, 100, 100, 0.5);
            opacity: 0.3;
        }
        
        #menu-screen {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(10, 5, 5, 0.6);
            backdrop-filter: blur(2px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; pointer-events: auto;
            text-align: center;
            transition: opacity 0.3s;
        }

        h1 { font-size: 60px; color: #a00; text-shadow: 4px 4px 0px #000, 0 0 20px #f00; letter-spacing: 5px; margin-bottom: 30px; border-bottom: 2px solid #500; padding-bottom: 10px; }
        .view-select-container { margin-bottom: 40px; }
        .view-label { font-size: 18px; color: #aaa; margin-bottom: 15px; letter-spacing: 2px; text-shadow: 1px 1px 0 #000; }
        .view-buttons { display: flex; gap: 15px; }
        .btn-view { background: rgba(0,0,0,0.7); border: 1px solid #444; color: #888; padding: 10px 20px; cursor: pointer; font-family: inherit; font-size: 16px; transition: all 0.2s; }
        .btn-view:hover { border-color: #800; color: #fff; }
        .btn-view.active { background-color: #700; color: #fff; border-color: #f00; box-shadow: 0 0 10px #500; font-weight: bold; }
        .action-buttons { display: flex; flex-direction: column; gap: 20px; min-width: 300px; }
        .btn-main { font-size: 24px; padding: 15px 40px; background-color: rgba(0,0,0,0.5); border: 2px solid #a00; color: #a00; cursor: pointer; font-family: inherit; text-transform: uppercase; letter-spacing: 3px; transition: all 0.2s; }
        .btn-main:hover { background-color: #a00; color: #000; box-shadow: 0 0 20px #f00; }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0% { text-shadow: 0 0 5px #a00; } 50% { text-shadow: 0 0 20px #f00; } 100% { text-shadow: 0 0 5px #a00; } }
        .hidden { display: none !important; }

        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 100px; color: #f00; font-weight: bold; text-shadow: 0 0 20px #000; font-family: 'Chiller', 'Courier New', serif; z-index: 200; pointer-events: none; }
        
        #coord-info { display: none; position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; font-size: 16px; background: rgba(0,0,0,0.5); padding: 5px; pointer-events: none; }
        #hitbox-status { display: none; position: absolute; bottom: 100px; left: 10px; color: lime; font-family: monospace; font-size: 12px; pointer-events: none; }

        /* ホットバー (1.5倍) */
        #hotbar-container { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 6px; 
            background-color: rgba(0, 0, 0, 0.4); padding: 6px; border-radius: 6px; 
            pointer-events: none; 
        }
        .slot { 
            width: 75px; height: 75px; 
            border: 3px solid #888; 
            background-color: rgba(50, 50, 50, 0.6); 
            display: flex; align-items: center; justify-content: center; 
            font-size: 14px; color: white; font-weight: bold; 
            position: relative; 
        }
        .slot.active { 
            border-color: white; 
            background-color: rgba(100, 100, 100, 0.8); 
            transform: scale(1.1); 
            box-shadow: 0 0 15px rgba(255,255,255,0.5); 
        }
        .slot span { position: absolute; bottom: 4px; right: 6px; }
        .slot-icon { 
            width: 60px; height: 60px; 
            object-fit: contain; 
            pointer-events: none;
            filter: drop-shadow(2px 2px 2px black);
        }

        /* 弾薬UI */
        #ammo-display {
            position: absolute; bottom: 30px; right: 30px;
            font-size: 60px; 
            font-weight: bold; color: #fff;
            text-shadow: 3px 3px 0 #000;
            font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
            display: none; 
        }
        #ammo-display span { font-size: 30px; color: #aaa; }
        #ammo-display.reloading { color: #f55; animation: blink 0.2s infinite; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.2; } 100% { opacity: 1; } }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="menu-screen">
        <h1>THE BACKROOMS</h1>
        <div class="view-select-container">
            <div class="view-label">- SELECT VIEWPOINT -</div>
            <div class="view-buttons">
                <!-- 初期状態で 1ST PERSON をアクティブに -->
                <button class="btn-view active" data-mode="2">1ST PERSON</button>
                <button class="btn-view" data-mode="0">3RD PERSON (REAR)</button>
                <button class="btn-view" data-mode="1">3RD PERSON (FRONT)</button>
            </div>
        </div>
        <div class="action-buttons">
            <button id="btn-start" class="btn-main pulse">ENTER THE ROOM</button>
            <button id="btn-resume" class="btn-main hidden">RESUME</button>
            <button id="btn-reset" class="btn-main hidden">RESET GAME</button>
        </div>
        <p style="margin-top:30px; color:#ccc; font-size:12px; text-shadow: 1px 1px 1px black;">
            WASD: Move / Mouse: Look / F5: Change View / Esc: Pause<br>
            Space: Jump / Shift: Crouch / Ctrl: Run / R: Reload<br>
            <span style="color:#f55">L-Click: Shoot</span> / <span style="color:#5f5">R-Click: Aim</span>
        </p>
    </div>

    <div id="coord-info">XYZ: 0.00 / 0.00 / 0.00</div>

    <div id="ui-layer">
        <div id="info" style="text-align: right; width: auto; right: 10px; left: auto;">
            Status: <span id="status">Loading Models...</span><br>
            Mode: <span id="view-mode-text">FPS</span><br>
            <span id="battle-log" style="color:red; font-weight:bold;"></span>
        </div>
        <div id="hitbox-status">[Hitboxes: ON]</div>

        <div id="hotbar-container">
            <div class="slot" id="slot-0"><div class="slot-img"><img src="photo/Melee_Damage.png" class="slot-icon"></div><span>1</span></div>
            <div class="slot active" id="slot-1"><div class="slot-img"><img src="photo/unnamed.png" class="slot-icon"></div><span>2</span></div>
            <div class="slot" id="slot-2"><div class="slot-img"><img src="photo/unnamed (1).png" class="slot-icon"></div><span>3</span></div>
            <div class="slot" id="slot-3"><span>4</span></div>
            <div class="slot" id="slot-4"><span>5</span></div>
        </div>

        <div id="ammo-display">30 <span>/ 30</span></div>
    </div>
    <div id="crosshair"></div>
    
    <div id="reticle-ammo"></div>

    <div id="game-over">CAUGHT</div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 設定 ---
        const PLAYER_SPEED = 0.08;
        const ENEMY_SPEED = 0.055;
        const MOUSE_SENSITIVITY = 0.002;
        const CHUNK_SIZE = 41.0; 
        
        // 物理設定
        const GRAVITY = 20.0;
        const JUMP_FORCE = 8.0;
        const CROUCH_HEIGHT_OFFSET = 0.8;

        let viewMode = 2; 
        const VIEW_CONFIG = [
            { name: "TPS (Rear)",  dist: 1.9, height: 1.8, offsetAngle: Math.PI },
            { name: "TPS (Front)", dist: 2.5, height: 1.8, offsetAngle: 0 },
            { name: "FPS",         dist: 0.1, height: 1.7, offsetAngle: Math.PI } 
        ];

        let isGameActive = false;
        let hasGameStarted = false;
        let isGameOver = false;
        let currentSlot = 1; // 初期装備: M16
        const TOTAL_SLOTS = 5;

        // --- 武器データ ---
        const WEAPON_DATA = {
            1: { // M16
                name: "M16",
                maxAmmo: 30,
                scale: 0.0012,
                rate: 333,
                pellets: 1,
                spreadHip: 0.08,
                spreadAds: 0.001,
                tpsPos: new THREE.Vector3(0.08, -0.00, 0.40),
                tpsRot: new THREE.Euler(3.07, -2.50, 0.00),
                fpsPosHip: new THREE.Vector3(0.25, -0.3, -0.6),
                fpsRotHip: new THREE.Euler(0, Math.PI + 0.05, 0),
                fpsPosAds: new THREE.Vector3(0.0, -0.19, -0.5),
                fpsRotAds: new THREE.Euler(0, Math.PI, 0),
                shootSound: 'sounds/拳銃を撃つ.mp3'
            },
            2: { // Shotgun
                name: "Shotgun",
                maxAmmo: 5,
                scale: 0.0012, 
                rate: 1000, 
                pellets: 6,
                spreadHip: 0.15,
                spreadAds: 0.05,
                tpsPos: new THREE.Vector3(0.08, -0.00, 0.40),
                tpsRot: new THREE.Euler(0, -2.50, Math.PI), 
                fpsPosHip: new THREE.Vector3(0.2, -0.3, -0.6),
                fpsRotHip: new THREE.Euler(Math.PI, Math.PI + 0.05, Math.PI),
                fpsPosAds: new THREE.Vector3(0.0, -0.2, -0.5),
                fpsRotAds: new THREE.Euler(Math.PI, Math.PI, Math.PI),
                shootSound: 'sounds/ショットガン発射.mp3'
            }
        };

        let ammoStock = { 1: 30, 2: 5 };

        let playerVelocityY = 0;
        let isGrounded = false;

        let enemyHealth = 5; 
        let isReloading = false;
        let isAiming = false;
        let isTriggerHeld = false; 
        let lastShotTime = 0;      
        const raycaster = new THREE.Raycaster(); 

        const menuScreen = document.getElementById('menu-screen');
        const btnStart = document.getElementById('btn-start');
        const btnResume = document.getElementById('btn-resume');
        const btnReset = document.getElementById('btn-reset');
        const viewButtons = document.querySelectorAll('.btn-view');
        const crosshair = document.getElementById('crosshair');
        const gameOverScreen = document.getElementById('game-over');
        const statusText = document.getElementById('status');
        const coordInfo = document.getElementById('coord-info');
        const hitboxStatus = document.getElementById('hitbox-status');
        const slots = document.querySelectorAll('.slot');
        const battleLog = document.getElementById('battle-log');
        const ammoDisplay = document.getElementById('ammo-display');
        const reticleAmmo = document.getElementById('reticle-ammo');

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a1a0d, 0.05);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000); 
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // --- ★ オーディオ設定 ---
        const listener = new THREE.AudioListener();
        camera.add(listener);

        // BGM: BGM.mp3
        const bgmSound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load('sounds/BGM.mp3', function(buffer) {
            bgmSound.setBuffer(buffer);
            bgmSound.setLoop(true);
            bgmSound.setLoopStart(0.03);
            bgmSound.offset = 0.03;
            // ★ BGM音量: 20%
            bgmSound.setVolume(0.2); 
        });

        // プレイヤー足音
        const playerStepSound = new THREE.Audio(listener);
        let playerStepBuffer = null;
        audioLoader.load('sounds/砂利の上を歩く走る.mp3', function(buffer) {
            playerStepBuffer = buffer;
            playerStepSound.setBuffer(buffer);
            playerStepSound.setLoop(true); 
            // ★ 足音音量: 1.5倍に
            playerStepSound.setVolume(1.5);
        });

        // 敵足音
        const enemyStepSound = new THREE.PositionalAudio(listener);
        audioLoader.load('sounds/馬が走る2.mp3', function(buffer) {
            enemyStepSound.setBuffer(buffer);
            enemyStepSound.setRefDistance(5); 
            enemyStepSound.setLoop(true);
            enemyStepSound.setVolume(1.0);
        });

        // 武器発射音プール
        const shotSoundPool = [];
        for(let i=0; i<5; i++) {
            shotSoundPool.push(new THREE.Audio(listener));
        }
        let shotSoundIndex = 0;

        function playShotSound(path) {
            const sound = shotSoundPool[shotSoundIndex];
            shotSoundIndex = (shotSoundIndex + 1) % shotSoundPool.length;
            
            if (sound.isPlaying) sound.stop();
            
            audioLoader.load(path, function(buffer) {
                sound.setBuffer(buffer);
                // ★ 銃撃音量: 75%
                sound.setVolume(0.75);
                sound.play();
            });
        }

        const ambientLight = new THREE.AmbientLight(0xffddaa, 0.4);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 15);
        scene.add(pointLight);

        let player, enemy;
        
        let m16Model = null;
        let sgModel = null; 
        let currentWeaponPivot = null; 
        let m16Pivot = new THREE.Group();
        let sgPivot = new THREE.Group();

        let m16BoxHelper = null; 
        let sgBoxHelper = null;
        let ammoMesh = null;
        let mixerPlayer, mixerEnemy;
        let mapTemplate = null;
        const loadedChunks = {};
        
        let playerBoxHelper, enemyBoxHelper;
        let showHitboxes = false;
        let showCoords = false;
        let f3ActionConsumed = false;

        const clock = new THREE.Clock();
        const keys = { w: false, a: false, s: false, d: false, f3: false, ctrl: false, space: false, shift: false }; 
        let cameraPitch = 0.0;
        
        viewButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                viewButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                viewMode = parseInt(btn.getAttribute('data-mode'));
                document.getElementById('view-mode-text').innerText = VIEW_CONFIG[viewMode].name;
                attachWeapon(); 
            });
        });

        function requestGameLock() { 
            document.body.requestPointerLock();
            
            // ★ ブラウザの自動再生ポリシー対策
            if (listener.context.state === 'suspended') {
                listener.context.resume();
            }

            // BGMが準備できていれば再生
            if (bgmSound.buffer && !bgmSound.isPlaying) bgmSound.play();
            
            if (enemy && !enemyStepSound.isPlaying && enemy.visible) enemyStepSound.play();
        }
        btnStart.addEventListener('click', requestGameLock);
        btnResume.addEventListener('click', requestGameLock);
        btnReset.addEventListener('click', () => { resetGame(); requestGameLock(); });

        function resetGame() {
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            statusText.innerText = "Running";
            statusText.style.color = "#ddd";
            battleLog.innerText = "";
            enemyHealth = 5; 
            
            ammoStock[1] = WEAPON_DATA[1].maxAmmo;
            ammoStock[2] = WEAPON_DATA[2].maxAmmo;
            
            isReloading = false;
            isAiming = false;
            isTriggerHeld = false;
            playerVelocityY = 0;
            currentSlot = 1; 
            
            updateAmmoUI();
            updateHotbarUI();
            attachWeapon(); 

            if (player) { player.position.set(0, 0, 0); player.rotation.set(0, 0, 0); }
            if (enemy) { 
                enemy.position.set(0, 0, 15); 
                enemy.visible = true; 
                if(!enemyStepSound.isPlaying) enemyStepSound.play();
            }
            cameraPitch = 0;
            
            Object.values(loadedChunks).forEach(chunk => {
                if (chunk.userData.debugHelper) scene.remove(chunk.userData.debugHelper);
                scene.remove(chunk);
            });
            for (const key in loadedChunks) delete loadedChunks[key];

            // ★ BGMリセット
            if (bgmSound.buffer) {
                if (bgmSound.isPlaying) bgmSound.stop();
                bgmSound.play();
            }
        }

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                isGameActive = true;
                if (!hasGameStarted) hasGameStarted = true;
                menuScreen.style.opacity = '0';
                setTimeout(() => { if(isGameActive) menuScreen.style.display = 'none'; }, 300);
                crosshair.style.display = 'block';
                
                if (listener.context.state === 'suspended') listener.context.resume();
                if(bgmSound.buffer && !bgmSound.isPlaying) bgmSound.play();
                
                if(enemy && enemy.visible && !enemyStepSound.isPlaying) enemyStepSound.play();
            } else {
                isGameActive = false;
                menuScreen.style.display = 'flex';
                requestAnimationFrame(() => { menuScreen.style.opacity = '1'; });
                crosshair.style.display = 'none';
                if (hasGameStarted) {
                    btnStart.classList.add('hidden'); btnResume.classList.remove('hidden'); btnReset.classList.remove('hidden');
                } else {
                    btnStart.classList.remove('hidden'); btnResume.classList.add('hidden'); btnReset.classList.add('hidden');
                }
                
                // ★ 足音は停止する（PauseではなくStop）
                if(playerStepSound.isPlaying) playerStepSound.stop();
                if(enemyStepSound.isPlaying) enemyStepSound.pause();
                // BGMは鳴らし続ける
            }
        });

        document.body.addEventListener('mousemove', (event) => {
            if (!isGameActive || !player || isGameOver) return;
            player.rotation.y -= event.movementX * MOUSE_SENSITIVITY;
            cameraPitch += event.movementY * MOUSE_SENSITIVITY;
            const limit = Math.PI / 2 - 0.1;
            cameraPitch = Math.max(-limit, Math.min(limit, cameraPitch));
        });

        document.body.addEventListener('mousedown', (event) => {
            if (!isGameActive || isGameOver) return;
            
            // ★ クリック時にも念のためResumeを入れる
            if (listener.context.state === 'suspended') listener.context.resume();

            if (event.button === 0 && (currentSlot === 1 || currentSlot === 2)) {
                isTriggerHeld = true;
                shootWeapon(); 
            }
            if (event.button === 2) {
                isAiming = true;
                crosshair.classList.add('aiming');
            }
        });

        document.body.addEventListener('mouseup', (event) => {
            if (event.button === 0) isTriggerHeld = false;
            if (event.button === 2) {
                isAiming = false;
                crosshair.classList.remove('aiming');
            }
        });
        document.addEventListener('contextmenu', event => event.preventDefault());

        function shootWeapon() {
            if (isReloading) return;
            
            const weapon = WEAPON_DATA[currentSlot];
            if (!weapon) return;

            if (ammoStock[currentSlot] <= 0) {
                reloadWeapon();
                return;
            }

            const now = performance.now();
            if (now - lastShotTime < weapon.rate * 0.5 && !isTriggerHeld) return; 

            playShotSound(weapon.shootSound);

            ammoStock[currentSlot]--;
            updateAmmoUI();
            lastShotTime = now; 

            const spreadBase = isAiming ? weapon.spreadAds : weapon.spreadHip;
            
            for (let i = 0; i < weapon.pellets; i++) {
                const xOffset = (Math.random() - 0.5) * spreadBase;
                const yOffset = (Math.random() - 0.5) * spreadBase;

                raycaster.setFromCamera(new THREE.Vector2(xOffset, yOffset), camera);
                const intersects = raycaster.intersectObjects(enemy && enemy.visible ? [enemy] : [], true);
                let endPoint;

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    endPoint = hit.point;
                    
                    enemyHealth--;
                    battleLog.innerText = `Enemy Hit! HP: ${enemyHealth}`;
                    
                    if (enemyHealth <= 0) {
                        enemy.visible = false;
                        battleLog.innerText = "Target Eliminated.";
                        if (enemyBoxHelper) enemyBoxHelper.visible = false;
                        if(enemyStepSound.isPlaying) enemyStepSound.stop();
                    }
                } else {
                    endPoint = raycaster.ray.at(100); 
                }

                const pivot = (currentSlot === 1) ? m16Pivot : sgPivot;
                const startPoint = pivot.getWorldPosition(new THREE.Vector3());
                startPoint.y += 0.05; 
                
                const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
                const points = [startPoint, endPoint];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                setTimeout(() => { scene.remove(line); geometry.dispose(); material.dispose(); }, 50);
            }
        }

        function reloadWeapon() {
            const weapon = WEAPON_DATA[currentSlot];
            if (!weapon) return;
            if (isReloading || ammoStock[currentSlot] === weapon.maxAmmo) return;
            
            isReloading = true;
            isTriggerHeld = false; 
            battleLog.innerText = "Reloading...";
            ammoDisplay.classList.add('reloading');

            setTimeout(() => {
                ammoStock[currentSlot] = weapon.maxAmmo;
                isReloading = false;
                battleLog.innerText = "";
                ammoDisplay.classList.remove('reloading');
                updateAmmoUI();
                attachWeapon(); 
            }, 2000);
        }

        // --- ★ 弾薬UI更新 (四角いゲージ) ---
        function updateAmmoUI() {
            const weapon = WEAPON_DATA[currentSlot];
            
            // 1. テキスト表示
            if (weapon) {
                ammoDisplay.style.display = 'block';
                ammoDisplay.innerHTML = `${ammoStock[currentSlot]} <span>/ ${weapon.maxAmmo}</span>`;
            } else {
                ammoDisplay.style.display = 'none';
            }

            // 2. 視覚ゲージ (四角を並べる)
            reticleAmmo.innerHTML = ''; // クリア
            if (weapon) {
                const current = ammoStock[currentSlot];
                const max = weapon.maxAmmo;
                
                for (let i = 0; i < max; i++) {
                    const pip = document.createElement('div');
                    pip.classList.add('ammo-pip');
                    
                    // スタイル調整 (M16は小さく、SGは大きく)
                    if (max > 10) { // M16
                        pip.style.width = '6px'; pip.style.height = '6px';
                    } else { // SG
                        pip.style.width = '12px'; pip.style.height = '12px';
                    }

                    // 撃った分は透明枠に
                    if (i >= current) {
                        pip.classList.add('empty');
                    }
                    reticleAmmo.appendChild(pip);
                }
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'F3') { e.preventDefault(); keys['f3'] = true; }
            if ((e.key === 'b' || e.key === 'B') && keys['f3']) { toggleHitboxes(); f3ActionConsumed = true; }
            
            if (e.key === 'F5') {
                e.preventDefault();
                viewMode = (viewMode + 1) % 3;
                document.getElementById('view-mode-text').innerText = VIEW_CONFIG[viewMode].name;
                viewButtons.forEach(b => b.classList.remove('active'));
                const targetBtn = document.querySelector(`.btn-view[data-mode="${viewMode}"]`);
                if(targetBtn) targetBtn.classList.add('active');
                attachWeapon(); 
                return;
            }
            
            if (e.key.toLowerCase() === 'r') reloadWeapon();
            if (e.key === 'Control') keys['ctrl'] = true; 
            if (e.code === 'Space' || e.key === ' ') { e.preventDefault(); keys['space'] = true; }
            if (e.key === 'Shift') keys['shift'] = true;

            if (e.key >= '1' && e.key <= '5') {
                currentSlot = parseInt(e.key) - 1;
                updateHotbarUI();
                attachWeapon();
            }
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => { 
            if (e.key === 'F3') {
                if (!f3ActionConsumed) toggleCoordinates();
                keys['f3'] = false; f3ActionConsumed = false;
            }
            if (e.key === 'Control') keys['ctrl'] = false;
            if (e.code === 'Space' || e.key === ' ') keys['space'] = false;
            if (e.key === 'Shift') keys['shift'] = false;

            keys[e.key.toLowerCase()] = false; 
        });

        window.addEventListener('wheel', (e) => {
            if(!isGameActive) return;
            if (e.deltaY > 0) currentSlot = (currentSlot + 1) % TOTAL_SLOTS;
            else currentSlot = (currentSlot - 1 + TOTAL_SLOTS) % TOTAL_SLOTS;
            updateHotbarUI();
            attachWeapon();
        });

        function updateHotbarUI() {
            slots.forEach((slot, index) => {
                if (index === currentSlot) slot.classList.add('active');
                else slot.classList.remove('active');
            });
            if (currentSlot === 2) crosshair.classList.add('shotgun');
            else crosshair.classList.remove('shotgun');
        }

        function attachWeapon() {
            if (!player) return;
            
            m16Pivot.removeFromParent(); m16Pivot.visible = false;
            sgPivot.removeFromParent(); sgPivot.visible = false;
            if(m16BoxHelper) m16BoxHelper.visible = false;
            if(sgBoxHelper) sgBoxHelper.visible = false;

            const weapon = WEAPON_DATA[currentSlot];
            
            if (weapon) {
                currentWeaponPivot = (currentSlot === 1) ? m16Pivot : sgPivot;
                currentWeaponPivot.visible = true;
                
                currentWeaponPivot.scale.set(weapon.scale, weapon.scale, weapon.scale);

                if (viewMode === 2) { 
                    camera.add(currentWeaponPivot);
                    currentWeaponPivot.position.copy(weapon.fpsPosHip);
                    currentWeaponPivot.rotation.copy(weapon.fpsRotHip);
                } else {
                    let handBone = null;
                    player.traverse(c => { if (c.isBone && c.name.includes('RightHand')) handBone = c; });
                    if (handBone) {
                        handBone.add(currentWeaponPivot);
                        currentWeaponPivot.position.copy(weapon.tpsPos); 
                        currentWeaponPivot.rotation.copy(weapon.tpsRot); 
                    } else {
                        player.add(currentWeaponPivot);
                        currentWeaponPivot.position.set(0.3, 1.2, 0.5);
                    }
                }
                
                if(showHitboxes) {
                    if (currentSlot === 1 && m16BoxHelper) m16BoxHelper.visible = true;
                    if (currentSlot === 2 && sgBoxHelper) sgBoxHelper.visible = true;
                }
                updateAmmoUI();
            } else {
                currentWeaponPivot = null;
                updateAmmoUI();
            }
        }

        function toggleHitboxes() {
            showHitboxes = !showHitboxes;
            hitboxStatus.style.display = showHitboxes ? 'block' : 'none';
            
            if (playerBoxHelper) playerBoxHelper.visible = showHitboxes;
            if (enemyBoxHelper) enemyBoxHelper.visible = showHitboxes;
            
            if (m16BoxHelper) m16BoxHelper.visible = (showHitboxes && currentSlot === 1);
            if (sgBoxHelper) sgBoxHelper.visible = (showHitboxes && currentSlot === 2);

            for (const key in loadedChunks) {
                const chunk = loadedChunks[key];
                if (chunk.userData.debugHelper) chunk.userData.debugHelper.visible = showHitboxes;
                else if (showHitboxes) {
                    const h = new THREE.BoxHelper(chunk, 0x00ff00);
                    scene.add(h); chunk.userData.debugHelper = h;
                }
            }
        }
        function toggleCoordinates() {
            showCoords = !showCoords;
            coordInfo.style.display = showCoords ? 'block' : 'none';
        }

        const loader = new GLTFLoader();

        loader.load('3Dmodel/backrooms.glb', (gltf) => {
            mapTemplate = gltf.scene;
            mapTemplate.scale.set(1.3, 1.3, 1.3);
            mapTemplate.traverse((child) => { if (child.isMesh) child.receiveShadow = true; });
            updateMapChunks();
        });

        loader.load('3Dmodel/escape_the_backrooms_hazmat.glb', (gltf) => {
            player = gltf.scene;
            player.position.set(0, 0, 0);
            if(gltf.animations.length > 0){
                mixerPlayer = new THREE.AnimationMixer(player);
                mixerPlayer.clipAction(gltf.animations[0]).play();
            } else {
                fixTPose(player);
            }
            playerBoxHelper = new THREE.BoxHelper(player, 0xffff00);
            playerBoxHelper.visible = false;
            scene.add(playerBoxHelper);
            
            scene.add(player);
            
            if(m16Model && sgModel) attachWeapon();
            checkLoadComplete();
        });

        loader.load('3Dmodel/bacteria_-_kane_pixels_backrooms.glb', (gltf) => {
            enemy = gltf.scene;
            enemy.scale.set(0.5, 0.5, 0.5); 
            enemy.position.set(0, 0, 15);
            enemy.traverse((child) => { if (child.isMesh) child.material.color.set(0x000000); });
            if(gltf.animations.length > 0){
                mixerEnemy = new THREE.AnimationMixer(enemy);
                mixerEnemy.clipAction(gltf.animations[0]).play();
            }
            enemyBoxHelper = new THREE.BoxHelper(enemy, 0xff0000);
            enemyBoxHelper.visible = false;
            scene.add(enemyBoxHelper);
            scene.add(enemy);
            checkLoadComplete();
        });

        // M16
        loader.load('3Dmodel/m16_assault_rifle.glb', (gltf) => {
            m16Model = gltf.scene;
            m16Model.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
            
            const box = new THREE.Box3().setFromObject(m16Model);
            const center = box.getCenter(new THREE.Vector3());
            m16Model.position.sub(center); 
            
            m16Pivot.add(m16Model);
            m16Pivot.visible = false;
            
            m16BoxHelper = new THREE.BoxHelper(m16Pivot, 0x0000ff);
            m16BoxHelper.visible = false;
            scene.add(m16BoxHelper);

            if(player && sgModel) attachWeapon();
        }, undefined, (e)=>{ console.error(e); statusText.innerText = "Error: M16 Not Found"; statusText.style.color="red"; });

        // Shotgun
        loader.load('3Dmodel/simple_old_shotgun.glb', (gltf) => {
            console.log("Shotgun Loaded");
            sgModel = gltf.scene;
            sgModel.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
            
            const box = new THREE.Box3().setFromObject(sgModel);
            const center = box.getCenter(new THREE.Vector3());
            sgModel.position.sub(center); 
            
            sgPivot.add(sgModel);
            sgPivot.visible = false;

            sgBoxHelper = new THREE.BoxHelper(sgPivot, 0x0000ff);
            sgBoxHelper.visible = false;
            scene.add(sgBoxHelper);

            if(player && m16Model) attachWeapon();
        }, undefined, (e)=>{ console.error(e); statusText.innerText = "Error: Shotgun Not Found"; statusText.style.color="red"; });

        loader.load('3Dmodel/5.56x45mm_mk262_ammunition_round.glb', (gltf) => {
            ammoMesh = gltf.scene;
            ammoMesh.scale.set(0.1, 0.1, 0.1);
        }, undefined, (error) => {});

        function checkLoadComplete() {
            if (player && enemy) document.getElementById('status').innerText = "Ready to Run";
        }

        function fixTPose(model) {
            model.traverse((child) => {
                if (child.isBone) {
                    const name = child.name; 
                    if (name.includes('LeftArm_')) { child.rotation.set(0,0,0); child.rotation.x = 1.4; child.rotation.z = 0.2; }
                    if (name.includes('RightArm_')) { child.rotation.set(0,0,0); child.rotation.x = 1.4; child.rotation.z = -0.2; }
                    if (name.includes('LeftForeArm_')) child.rotation.set(0,0,0); 
                    if (name.includes('RightForeArm_')) child.rotation.set(0,0,0); 
                }
            });
        }

        function updateMapChunks() {
            if (!player || !mapTemplate) return;
            const pX = player.position.x; const pZ = player.position.z;
            const chunkX = Math.round(pX / CHUNK_SIZE); const chunkZ = Math.round(pZ / CHUNK_SIZE);
            const activeKeys = new Set();
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    const cx = chunkX + x; const cz = chunkZ + z; const key = `${cx},${cz}`; activeKeys.add(key);
                    if (!loadedChunks[key]) {
                        const clone = mapTemplate.clone();
                        clone.position.set(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
                        if (showHitboxes) { const h = new THREE.BoxHelper(clone, 0x00ff00); scene.add(h); clone.userData.debugHelper = h; }
                        scene.add(clone); loadedChunks[key] = clone;
                    }
                }
            }
            for (const key in loadedChunks) {
                if (!activeKeys.has(key)) {
                    const chunk = loadedChunks[key];
                    if (chunk.userData.debugHelper) scene.remove(chunk.userData.debugHelper);
                    scene.remove(chunk); delete loadedChunks[key];
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const delta = clock.getDelta();
            
            const weapon = WEAPON_DATA[currentSlot];
            if (isTriggerHeld && weapon && !isReloading && !isGameOver && isGameActive) {
                if (currentTime - lastShotTime >= weapon.rate) {
                    shootWeapon();
                }
            }

            if (mixerPlayer && isGameActive) mixerPlayer.update(delta);
            if (mixerEnemy && isGameActive) mixerEnemy.update(delta);
            
            if (playerBoxHelper) playerBoxHelper.update();
            if (enemyBoxHelper && enemy && enemy.visible) enemyBoxHelper.update();
            if (m16BoxHelper) m16BoxHelper.update();
            if (sgBoxHelper) sgBoxHelper.update();

            // ADSアニメーション
            if (currentWeaponPivot && currentWeaponPivot.visible && viewMode === 2) {
                const weapon = WEAPON_DATA[currentSlot];
                const targetPos = isAiming && !isReloading ? weapon.fpsPosAds : weapon.fpsPosHip;
                const targetRot = isAiming && !isReloading ? weapon.fpsRotAds : weapon.fpsRotHip;
                
                currentWeaponPivot.position.lerp(targetPos, 0.2);
                currentWeaponPivot.rotation.x += (targetRot.x - currentWeaponPivot.rotation.x) * 0.2;
                currentWeaponPivot.rotation.y += (targetRot.y - currentWeaponPivot.rotation.y) * 0.2;
                currentWeaponPivot.rotation.z += (targetRot.z - currentWeaponPivot.rotation.z) * 0.2;
                
                const targetFov = isAiming && !isReloading ? 60 : 75;
                if (Math.abs(camera.fov - targetFov) > 0.1) {
                    camera.fov += (targetFov - camera.fov) * 0.2;
                    camera.updateProjectionMatrix();
                }
            } else if (viewMode !== 2 && isGameActive) {
                const targetFov = isAiming && !isReloading ? 60 : 75;
                if (Math.abs(camera.fov - targetFov) > 0.1) {
                    camera.fov += (targetFov - camera.fov) * 0.2;
                    camera.updateProjectionMatrix();
                }
            }

            if (isReloading && currentWeaponPivot) currentWeaponPivot.rotation.x -= 0.1;

            if (showCoords && player) {
                coordInfo.innerText = `XYZ: ${player.position.x.toFixed(2)} / ${player.position.y.toFixed(2)} / ${player.position.z.toFixed(2)}`;
            }

            if (isGameOver) { renderer.render(scene, camera); return; }

            if (player && isGameActive) {
                let speedMultiplier = 1.0;
                let crouchOffset = 0;
                let isMoving = false;

                if (keys.shift) {
                    speedMultiplier *= 0.5; 
                    crouchOffset = CROUCH_HEIGHT_OFFSET;
                } else if (keys.ctrl) {
                    speedMultiplier *= 1.25; 
                }

                if (isReloading) speedMultiplier *= 0.75; 

                const currentSpeed = PLAYER_SPEED * speedMultiplier;

                const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                
                if (keys.w) { player.position.add(forward.clone().multiplyScalar(currentSpeed)); isMoving = true; }
                if (keys.s) { player.position.add(forward.clone().multiplyScalar(-currentSpeed)); isMoving = true; }
                if (keys.a) { player.position.add(right.clone().multiplyScalar(currentSpeed)); isMoving = true; }
                if (keys.d) { player.position.add(right.clone().multiplyScalar(-currentSpeed)); isMoving = true; }

                // ★ プレイヤー足音制御 (Pause -> Stopに変更)
                if (isMoving && isGrounded && !playerStepSound.isPlaying) {
                    playerStepSound.play();
                } else if ((!isMoving || !isGrounded) && playerStepSound.isPlaying) {
                    playerStepSound.stop(); // 変更
                }
                // 再生速度変更
                if (playerStepSound.isPlaying) {
                    if (keys.ctrl) playerStepSound.setPlaybackRate(1.5);
                    else if (keys.shift) playerStepSound.setPlaybackRate(0.8);
                    else playerStepSound.setPlaybackRate(1.0);
                }

                if (keys.space && isGrounded) {
                    playerVelocityY = JUMP_FORCE;
                    isGrounded = false;
                }

                playerVelocityY -= GRAVITY * delta;
                player.position.y += playerVelocityY * delta;

                if (player.position.y <= 0) {
                    player.position.y = 0;
                    playerVelocityY = 0;
                    isGrounded = true;
                }
                
                updateMapChunks();
                pointLight.position.copy(player.position);
                pointLight.position.y += 2;
                
                const config = VIEW_CONFIG[viewMode];
                player.visible = (viewMode !== 2); 
                const targetPosition = player.position.clone();
                targetPosition.y += config.height - crouchOffset; 

                const yaw = player.rotation.y + config.offsetAngle;
                const pitch = cameraPitch;
                const horizontalDist = config.dist * Math.cos(pitch);
                const verticalDist = config.dist * Math.sin(pitch);
                camera.position.x = targetPosition.x + horizontalDist * Math.sin(yaw);
                camera.position.y = targetPosition.y + verticalDist;
                camera.position.z = targetPosition.z + horizontalDist * Math.cos(yaw);
                camera.lookAt(targetPosition);
            }
            if (enemy && enemy.visible && player && isGameActive) {
                enemy.lookAt(player.position);
                enemy.translateZ(ENEMY_SPEED);
                if (player.position.distanceTo(enemy.position) < 1.0) {
                    isGameOver = true;
                    document.exitPointerLock();
                    document.getElementById('game-over').style.display = 'block';
                }
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>