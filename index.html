<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>The Backrooms - Found Footage</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #eec; font-family: 'Courier New', Courier, monospace; 
            text-align: center; pointer-events: none;
            background: rgba(20, 20, 10, 0.8); padding: 30px; border: 1px solid #775;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        h1 { font-size: 24px; text-shadow: 2px 2px 0 #000; margin-bottom: 20px; color: #ffeb3b; }
        p { font-size: 14px; color: #bbb; line-height: 1.6; }
        .key { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>THE BACKROOMS</h1>
        <p>VHS RECORDING - SEP 23 1996</p>
        <p>----------------------------</p>
        <p><span class="key">S</span> : Forward (前進)</p>
        <p><span class="key">W</span> : Backward (後退)</p>
        <p><span class="key">Mouse</span> : Look</p>
        <p>----------------------------</p>
        <p>CLICK TO PLAY</p>
    </div>
    <canvas id="glslCanvas"></canvas>

    <script type="text/javascript" src="https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js"></script>

    <script>
        const canvas = document.getElementById('glslCanvas');
        const sandbox = new GlslCanvas(canvas);
        const instr = document.getElementById('instructions');

        const fragShader = `
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 u_resolution;
uniform float u_time;
uniform vec3 u_camPos;
uniform vec2 u_camRot;

#define R u_resolution
#define T u_time

// --- Noise Functions ---
float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    for (int i=0; i<4; i++) {
        v += noise(p) * a;
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}

// --- Scene Mapping ---
float map(vec3 p) {
    // 部屋の高さ (2.8m)
    float floorDist = p.y; 
    float ceilDist = 2.8 - p.y; 
    
    // 無限の壁生成
    float spacing = 6.0; // 少し広めの廊下
    vec3 q = p;
    vec2 id = floor(q.xz / spacing);
    q.xz = mod(q.xz, spacing) - spacing * 0.5;
    
    // ランダムな壁の配置パターン
    float h = hash(id);
    float thick = 0.2; 
    float dWall = 100.0;
    
    vec3 b = q;
    // 多様な壁のパターン
    if (h < 0.2) {
        // 角柱
        dWall = length(max(abs(b) - vec3(1.0, 2.0, 1.0), 0.0));
    } else if (h < 0.5) {
        // 横壁
        dWall = length(max(abs(b) - vec3(spacing*0.6, 2.0, thick), 0.0));
    } else if (h < 0.8) {
        // 縦壁
        dWall = length(max(abs(b) - vec3(thick, 2.0, spacing*0.6), 0.0));
    }
    
    // 巾木 (Baseboard) - 床近くを少し膨らませる
    float baseboard = (p.y < 0.25 && p.y > 0.0) ? dWall - 0.08 : dWall;
    
    return min(min(floorDist, ceilDist), baseboard);
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(0.005, 0.0);
    return normalize(vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
    ));
}

void main() {
    // レンズ歪み（魚眼効果）
    vec2 uv = (gl_FragCoord.xy * 2.0 - R) / R.y;
    float r2 = dot(uv, uv);
    uv *= 1.0 + 0.15 * r2; // 歪みを加える
    
    vec3 ro = u_camPos; 
    vec3 rd = normalize(vec3(uv, 1.2)); // FOV狭めで閉塞感を出す

    // カメラ回転
    float pitch = u_camRot.y;
    float yaw = u_camRot.x;
    mat2 rotX = mat2(cos(pitch), -sin(pitch), sin(pitch), cos(pitch));
    mat2 rotY = mat2(cos(yaw), -sin(yaw), sin(yaw), cos(yaw));
    rd.yz *= rotX;
    rd.xz *= rotY;
    
    // レイマーチング
    float t = 0.0;
    float d = 0.0;
    for(int i = 0; i < 100; i++) {
        vec3 p = ro + rd * t;
        d = map(p);
        if(d < 0.001 || t > 35.0) break;
        t += d;
    }
    
    vec3 col = vec3(0.0);
    
    if(t < 35.0) {
        vec3 p = ro + rd * t;
        vec3 n = getNormal(p);
        
        // --- マテリアル ---
        
        // 1. 床 (Damp Carpet)
        if (p.y < 0.01) {
            float n1 = fbm(p.xz * 6.0);
            float n2 = fbm(p.xz * 30.0);
            // 湿った茶色っぽい黄色
            col = vec3(0.55, 0.5, 0.25); 
            col *= 0.5 + 0.5 * n1; // 大きなムラ
            col *= 0.8 + 0.3 * n2; // 細かい繊維
            // シミ汚れ
            float stain = smoothstep(0.4, 0.7, noise(p.xz * 0.8));
            col *= 1.0 - stain * 0.4;
        } 
        // 2. 天井 (Acoustic Tiles)
        else if (p.y > 2.79) {
            vec2 tile = fract(p.xz * 0.5) - 0.5;
            float grid = smoothstep(0.47, 0.49, max(abs(tile.x), abs(tile.y)));
            col = vec3(0.8, 0.8, 0.75) * (1.0 - grid * 0.3);
            col *= 0.8 + 0.1 * noise(p.xz * 20.0);
            
            // 蛍光灯
            vec2 id = floor(p.xz * 0.5);
            if (hash(id) > 0.85) {
                // 不規則なフリッカー
                float blink = smoothstep(0.2, 0.8, noise(vec2(T * 15.0, hash(id))));
                // たまに消えかける
                float broken = step(0.02, hash(id + vec2(1.0)));
                col += vec3(2.0, 1.9, 1.6) * (0.8 + 0.2 * blink) * broken;
            }
        } 
        // 3. 壁 (The Mono-Yellow)
        else {
            // 壁紙のパターン（縦縞のようなノイズ）
            float pat = noise(vec2(p.x * 10.0, p.y * 4.0));
            pat += noise(vec2(p.z * 10.0, p.y * 4.0));
            // あの特有の黄色
            col = vec3(0.85, 0.75, 0.45); 
            col += (pat - 0.5) * 0.08;
            
            // 巾木の色
            if (p.y < 0.25) col = vec3(0.35, 0.25, 0.15);
        }
        
        // --- ライティング ---
        // アンビエントオクルージョン風の影
        float corner = smoothstep(0.0, 0.8, p.y) * smoothstep(2.8, 2.0, p.y);
        // ポイントライト（カメラ位置付近からの光）
        float light = 1.0 / (1.0 + t * t * 0.08);
        
        col *= corner * 0.7 + 0.3; // 全体的に薄暗く
        col += col * light * 0.5; // フラッシュライト効果

        // 距離フォグ (黄色い闇)
        vec3 fogCol = vec3(0.7, 0.6, 0.35);
        col = mix(col, fogCol, 1.0 - exp(-t * 0.15));
        
    } else {
        col = vec3(0.7, 0.6, 0.35); // 遠景色
    }
    
    // --- VHS Post Processing ---
    
    // 1. 色収差 (Chromatic Aberration)
    // レンズの端ほど色がずれる
    float ca = length(uv) * 0.02;
    col.r += 0.02 * hash(vec2(uv.y, T)); // 赤チャンネルに少しノイズ
    col.b = mix(col.b, col.g, 0.5); // 青を少し劣化させる
    
    // 2. フィルムグレイン
    float grain = hash(uv * 2.0 + mod(T, 10.0));
    col *= 0.9 + 0.2 * grain;
    
    // 3. ビネット (四隅を暗く)
    col *= smoothstep(1.5, 0.6, length(uv));
    
    // 4. ガンマとコントラスト (ビデオテープ風)
    col = pow(col, vec3(0.6)); // ガンマ
    col = (col - 0.5) * 1.1 + 0.5; // コントラスト強調

    gl_FragColor = vec4(col, 1.0);
}
        `;

        sandbox.load(fragShader);
        
        // 初期位置
        let camPos = { x: 0.5, y: 1.6, z: 0.5 };
        let camRot = { x: 0, y: 0 };
        // 歩行アニメーション用
        let walkTime = 0; 
        const keys = {};

        canvas.onclick = () => canvas.requestPointerLock();
        document.addEventListener('pointerlockchange', () => {
            instr.style.display = (document.pointerLockElement === canvas) ? 'none' : 'block';
        });

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        window.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas) {
                // 右移動で右を向く (Standard) => X座標をマイナスで回す
                camRot.x -= e.movementX * 0.003; 
                
                // 上移動で上を向く (Standard) => Y座標（Pitch）を足す
                // (GLSLの回転行列と座標系に合わせると、通常 e.movementY は下移動がプラスなので
                //  上移動はマイナス。上を向くにはPitchを減らす必要がある場合と増やす場合がある。
                //  前回の成功例に基づき調整)
                camRot.y += e.movementY * 0.003; 
                
                camRot.y = Math.max(-1.4, Math.min(1.4, camRot.y));
            }
        });

        function loop() {
            const speed = 0.07; 

            if (document.pointerLockElement === canvas) {
                const yaw = camRot.x;
                const fwdX = Math.sin(yaw);
                const fwdZ = -Math.cos(yaw);
                const rightX = Math.cos(yaw);
                const rightZ = Math.sin(yaw);
                
                let moving = false;

                // --- 指定された操作設定 ---
                // S: 前進 (Forward)
                if (keys['KeyS']) { 
                    camPos.x += fwdX * speed; 
                    camPos.z += fwdZ * speed; 
                    moving = true;
                }
                // W: 後退 (Backward)
                if (keys['KeyW']) { 
                    camPos.x -= fwdX * speed; 
                    camPos.z -= fwdZ * speed; 
                    moving = true;
                }
                
                // A: 左 (Left) / D: 右 (Right)
                if (keys['KeyA']) { 
                    camPos.x -= rightX * speed; 
                    camPos.z -= rightZ * speed; 
                    moving = true;
                }
                if (keys['KeyD']) { 
                    camPos.x += rightX * speed; 
                    camPos.z += rightZ * speed; 
                    moving = true;
                }
                
                // カメラの手ブレ（Head Bobbing）
                // 歩いている時だけ視点を上下左右に揺らす
                if (moving) {
                    walkTime += 0.15;
                    // Y軸の揺れ（足音）
                    camPos.y = 1.6 + Math.sin(walkTime * 2.0) * 0.05;
                    // X軸の揺れ（体のひねり）をカメラ回転に加算したいが、JSではPositionのみ揺らす
                    // 簡易的に横にも少し揺らす
                    let sway = Math.cos(walkTime) * 0.02;
                    // Note: 本当はRotに加算したいが、Uniformを汚さないようPositionで微調整
                } else {
                    // 止まったらゆっくり元の高さに戻る
                    camPos.y += (1.6 - camPos.y) * 0.1;
                }
            }

            sandbox.setUniform('u_camPos', camPos.x, camPos.y, camPos.z);
            sandbox.setUniform('u_camRot', camRot.x, camRot.y);

            requestAnimationFrame(loop);
        }

        loop();

    </script>
</body>
</html>